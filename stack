#!/usr/bin/env python

#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import os
import os.path
import sys
import re

#TODO is this needed?
sys.path.append("devstack")

import Logger
import Options

#TODO fix these
from Util import (welcome, rcf8222date, determine_os,
                    prioritize_components, resolve_dependencies)
from Util import (NOVA, GLANCE, QUANTUM, SWIFT, KEYSTONE,
                    HORIZON, DB, RABBIT, KEYSTONE_CLIENT,
                    NOVA_CLIENT, OPENSTACK_X)
from Util import(INSTALL, UNINSTALL, START, STOP,
                  ACTIONS, COMPONENT_NAMES, NAMES_PRIORITY, COMPONENT_DEPENDENCIES,
                  UBUNTU11, RHEL6,
                  STACK_CFG_LOC, DEVSTACK)
from Shell import (mkdir, joinpths, unlink)
from Exceptions import (NoTraceException)

import Glance
import Horizon
import Keystone
import Nova
import Quantum
import Config
import Swift
import Db
import Rabbit
import Config
import KeystoneClient
import NovaClient
import OpenstackX

LOG = Logger.getLogger("install")

#this determines what classes to use to install/uninstall/...
ACTION_CLASSES = {
    INSTALL: {
        NOVA: Nova.NovaInstaller,
        GLANCE: Glance.GlanceInstaller,
        QUANTUM: Quantum.QuantumInstaller,
        SWIFT: Swift.SwiftInstaller,
        HORIZON: Horizon.HorizonInstaller,
        KEYSTONE: Keystone.KeystoneInstaller,
        DB: Db.DBInstaller,
        RABBIT: Rabbit.RabbitInstaller,
        KEYSTONE_CLIENT: KeystoneClient.KeyStoneClientInstaller,
        NOVA_CLIENT: NovaClient.NovaClientInstaller,
        OPENSTACK_X: OpenstackX.OpenstackXInstaller,
    },
    UNINSTALL: {
        NOVA: Nova.NovaUninstaller,
        GLANCE: Glance.GlanceUninstaller,
        QUANTUM: Quantum.QuantumUninstaller,
        SWIFT: Swift.SwiftUninstaller,
        HORIZON: Horizon.HorizonUninstaller,
        KEYSTONE: Keystone.KeystoneUninstaller,
        DB: Db.DBUninstaller,
        RABBIT: Rabbit.RabbitUninstaller,
        KEYSTONE_CLIENT: KeystoneClient.KeyStoneClientUninstaller,
        NOVA_CLIENT: NovaClient.NovaClientUninstaller,
        OPENSTACK_X: OpenstackX.OpenstackXUninstaller,
    },
    START: {
        NOVA: Nova.NovaRuntime,
        GLANCE: Glance.GlanceRuntime,
        QUANTUM: Quantum.QuantumRuntime,
        SWIFT: Swift.SwiftRuntime,
        HORIZON: Horizon.HorizonRuntime,
        KEYSTONE: Keystone.KeystoneRuntime,
        DB: Db.DBRuntime,
        RABBIT: Rabbit.RabbitRuntime,
        KEYSTONE_CLIENT: KeystoneClient.KeyStoneClientRuntime,
        NOVA_CLIENT: NovaClient.NovaClientRuntime,
        OPENSTACK_X: OpenstackX.OpenstackXRuntime,
    },
    STOP: {
        NOVA: Nova.NovaRuntime,
        GLANCE: Glance.GlanceRuntime,
        QUANTUM: Quantum.QuantumRuntime,
        SWIFT: Swift.SwiftRuntime,
        HORIZON: Horizon.HorizonRuntime,
        KEYSTONE: Keystone.KeystoneRuntime,
        DB: Db.DBRuntime,
        RABBIT: Rabbit.RabbitRuntime,
        KEYSTONE_CLIENT: KeystoneClient.KeyStoneClientRuntime,
        NOVA_CLIENT: NovaClient.NovaClientRuntime,
        OPENSTACK_X: OpenstackX.OpenstackXRuntime,
    },
}


def get_package_manager_class(distro):
    klass = None
    if(distro == UBUNTU11):
        #late import required
        #TODO better way to do this?
        from packaging import Apt
        klass = Apt.AptPackager
    elif(distro == RHEL6):
        #late import required
        #TODO better way to do this?
        from packaging import Yum
        klass = Yum.YumPackager
    return klass


def get_config(action):
    fn = STACK_CFG_LOC
    LOG.info("Loading config from %s" % (fn))
    cfg = Config.EnvConfigParser()
    cfg.read(fn)
    return cfg


def print_cfgs(cfg, action):

    #this will make the items nice and pretty
    def item_format(k, v):
        return "\t%s=%s" % (str(k), str(v))

    def map_print(mp):
        for key in sorted(mp.keys()):
            value = mp.get(key)
            LOG.info(item_format(key, value))

    #now make it pretty
    passwords_gotten = cfg.pws
    full_cfgs = cfg.configs_fetched
    db_dsns = cfg.db_dsns
    if(len(passwords_gotten) or len(full_cfgs) or len(db_dsns)):
        LOG.info("After %s your config is:" % (action))
        if(len(passwords_gotten)):
            LOG.info("Passwords:")
            map_print(passwords_gotten)
        if(len(full_cfgs)):
            #TOD
            #better way to do this?? (ie a list difference?)
            filtered_mp = dict()
            for key in full_cfgs.keys():
                if(key in passwords_gotten):
                    continue
                filtered_mp[key] = full_cfgs.get(key)
            if(len(filtered_mp)):
                LOG.info("Configs:")
                map_print(filtered_mp)
        if(len(db_dsns)):
            LOG.info("Data source names:")
            map_print(db_dsns)


def runner(action_name, component_order, components_info, distro, root_dir, program_args):
    #have to make the root dir....
    if(action_name == INSTALL):
        mkdir(root_dir)
    pkg_manager_cls = get_package_manager_class(distro)
    pkg_manager = pkg_manager_cls(distro)
    config = get_config(action_name)
    LOG.info("Will %s [%s] (in that order) using root directory \"%s\"" % (action_name, ", ".join(component_order), root_dir))
    results = list()
    class_lookup = ACTION_CLASSES.get(action_name)
    force = program_args.get('force', False)
    for c in component_order:
        component_info = components_info.get(c) or list()
        klass = class_lookup.get(c)
        instance = klass(components=set(component_order), distro=distro,
                            pkg=pkg_manager, cfg=config, root=root_dir,
                            component_info=component_info)
        if(action_name == INSTALL):
            LOG.info("Downloading %s." % (c))
            am_downloaded = instance.download()
            LOG.info("Performed %s downloads." % (str(am_downloaded)))
            LOG.info("Configuring %s." % (c))
            am_configured = instance.configure()
            LOG.info("Configured %s files." % (str(am_configured)))
            LOG.info("Pre-installing %s." % (c))
            instance.pre_install()
            LOG.info("Installing %s." % (c))
            instance.install()
            LOG.info("Post-installing %s." % (c))
            trace = instance.post_install()
            if(trace):
                LOG.info("Finished install of %s - check %s for traces of what happened." % (c, trace))
                results.append(trace)
            else:
                LOG.info("Finished install of %s" % (c))
        elif(action_name == STOP):
            try:
                LOG.info("Stopping %s." % (c))
                stop_am = instance.stop()
                LOG.info("Stopped %s applications." % (str(stop_am)))
                LOG.info("Finished stop of %s" % (c))
            except NoTraceException, e:
                if(force):
                    LOG.info("Passing on stopping %s since no trace file was found." % (c))
                else:
                    raise
        elif(action_name == START):
            LOG.info("Starting %s." % (c))
            start_info = instance.start()
            if(type(start_info) == list):
                LOG.info("Check [%s] for traces of what happened." % (", ".join(start_info)))
                results = results + start_info
            elif(type(start_info) == int):
                LOG.info("Started %s applications." % (str(start_info)))
            LOG.info("Finished start of %s." % (c))
        elif(action_name == UNINSTALL):
            try:
                LOG.info("Unconfiguring %s." % (c))
                instance.unconfigure()
                LOG.info("Uninstalling %s." % (c))
                instance.uninstall()
            except NoTraceException, e:
                if(force):
                    LOG.info("Passing on uninstalling %s since no trace file was found." % (c))
                else:
                    raise
    #display any configs touched...
    print_cfgs(config, action_name)
    #attempt to remove the root dir (might fail if not empty)
    if(action_name == UNINSTALL):
        try:
            os.rmdir(root_dir)
        except OSError, e:
            pass
    return results


def check_root(action, rootdir):
    if(action == INSTALL):
        root_there = False
        if(os.path.isdir(rootdir)):
            sublisting = os.listdir(rootdir)
            if(len(sublisting) != 0):
                #something exists, not good
                root_there = True
        if(root_there):
            LOG.error("Root directory [%s] already exists (and it's not empty)! "\
                      "Please remove it or uninstall components!" % (rootdir))
            return False
        else:
            return True
    else:
        return True


def parse_action(action):
    if(action == None):
        return None
    action = action.strip().lower()
    if(not (action in ACTIONS)):
        return None
    return action


def parse_components(components, assume_all=False):
    #none provided
    if(components == None):
        components = list()
    #
    EXT_COMPONENT = re.compile(r"^\s*([\w-]+)(?:\((.*)\))?\s*$")
    adjusted_components = dict()
    for c in components:
        mtch = EXT_COMPONENT.match(c)
        if(mtch):
            component_name = mtch.group(1)
            component_name = component_name.lower().strip()
            if(component_name not in COMPONENT_NAMES):
                continue
            component_opts = mtch.group(2)
            components_opts_cleaned = list()
            if(component_opts == None or len(component_opts) == 0):
                pass
            else:
                sp_component_opts = component_opts.split(",")
                for co in sp_component_opts:
                    cleaned_opt = co.strip()
                    if(len(cleaned_opt)):
                        components_opts_cleaned.append(cleaned_opt)
            adjusted_components[component_name] = components_opts_cleaned
    #should we adjust them??
    if(len(adjusted_components) == 0):
        all_components = dict()
        if(assume_all):
            for c in (COMPONENT_NAMES):
                all_components[c] = list()
        adjusted_components = all_components
    return adjusted_components


def check_python():
    py_version = sys.version_info
    major = py_version[0]
    minor = py_version[1]
    if(major < 2 or (major == 2 and minor < 6)):
        return False
    if(major >= 3):
        LOG.warn("%s has not been tested in python %s, use at your own risk!" % (DEVSTACK, major))
    return True


def run_list_only(prog, args):
    components = parse_components(args.pop("components"), True).keys()
    components = sorted(components)
    components.reverse()
    shown = set()
    left_show = list(components)
    while(len(left_show) != 0):
        c = left_show.pop()
        deps = COMPONENT_DEPENDENCIES.get(c) or []
        cname = ""
        if(len(deps) >= 1):
            cname = "component"
            if(cname > 1):
                cname += "s"
            cname += ":"
        if(len(deps) == 0):
            cname = "no components."
        LOG.info("%s depends on %s" % (c, cname))
        if(len(deps)):
            for d in deps:
                LOG.info("\t%s" % (d))
        shown.add(c)
        for d in deps:
            if(d not in shown and d not in left_show):
                left_show.append(d)
    return True


def run_action(prog, args):
    components = parse_components(args.pop("components"))
    if(len(components) == 0):
        LOG.error("No components specified!")
        LOG.info("Perhaps you should try %s --help" % (prog))
        return False
    #extract + normalize the action
    ignore_deps = args.pop('ignore_deps', False)
    action = parse_action(args.pop("action"))
    if(not action):
        LOG.error("No valid action specified!")
        LOG.info("Perhaps you should try %s --help" % (prog))
        return False
    rootdir = args.pop("dir") or ""
    if(len(rootdir) == 0 or not check_root(action, rootdir)):
        LOG.error("No valid root directory specified!")
        LOG.info("Perhaps you should try %s --help" % (prog))
        return False
    #ensure os/distro is known
    (install_os, plt) = determine_os()
    if(install_os == None):
        LOG.error("Unsupported operating system/distro: %s" % (plt))
        return False
    #start it
    welcome(action)
    #need to figure out dependencies for components (if any)
    if(not ignore_deps):
        new_components = resolve_dependencies(action, components.keys())
        component_diff = new_components.difference(components.keys())
        if(len(component_diff)):
            LOG.info("Having to install dependent components: [%s]" % (", ".join(component_diff)))
            #TBD - probably need to do this better
            for new_component in component_diff:
                components[new_component] = list()
    #get the right component order (by priority)
    component_order = prioritize_components(components.keys())
    #now do it!
    LOG.info("Starting action [%s] on %s for operating system/distro [%s]" % (action, rcf8222date(), install_os))
    resultList = runner(action, component_order, components, install_os, rootdir, args)
    LOG.info("Finished action [%s] on %s" % (action, rcf8222date()))
    if(resultList and len(resultList)):
        msg = "Check [%s] for traces of what happened." % (", ".join(resultList))
        LOG.info(msg)
    return True


def main():
    if(not check_python()):
        LOG.error("Your python version is to old, please upgrade to >= 2.6!")
        return 1
    #parse and get it done!
    args = Options.parse()
    me = os.path.basename(sys.argv[0])
    #figure out what to do
    only_list_deps = args.pop('list_deps', False)
    rc_ok = False
    if(only_list_deps):
        rc_ok = run_list_only(me, args)
    else:
        rc_ok = run_action(me, args)
    if(rc_ok):
        return 0
    else:
        return 1


if __name__ == "__main__":
    rc = main()
    sys.exit(rc)
